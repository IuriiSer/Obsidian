[Source](https://habr.com/ru/company/postgrespro/blog/326096/)

## Индексы

Индексы в PostgreSQL — специальные объекты базы данных, предназначенные в основном для ускорения доступа к данным. Это вспомогательные структуры: любой индекс можно удалить и восстановить заново по информации в таблице. Иногда приходится слышать, что СУБД может работать и без индексов, просто медленно. Однако это не так, ведь индексы служат также для поддержки некоторых ограничений целостности.  
  
В настоящее время в PostgreSQL 9.6 встроены шесть разных видов индексов, и еще один доступен как расширение — это стало возможным благодаря важным изменениям в версии 9.6. Так что в ближайшее время стоит ожидать появления и других типов индексов.

Несмотря на все различия между типами индексов (называемыми также _методами доступа_), в конечном счете любой из них устанавливает соответствие между ключом (например, значением проиндексированного столбца) и строками таблицы, в которых этот ключ встречается. Строки идентифицируются с помощью **TID (tuple id)**, который состоит из номера блока файла и позиции строки внутри блока. Тогда, зная ключ или некоторую информацию о нем, можно быстро прочитать те строки, в которых может находиться интересующая нас информация, не просматривая всю таблицу полностью.

Важно понимать, что индекс, ускоряя доступ к данным, взамен требует определенных затрат на свое поддержание. При любой операции над проиндексированными данными — будь то вставка, удаление или обновление строк таблицы, — индексы, созданные для этой таблицы, должны быть перестроены, причем в рамках той же транзакции. Заметим, что обновление полей таблицы, по которым не создавались индексы, не приводит к перестроению индексов; этот механизм называется **HOT (Heap-Only Tuples)**.  
  
Расширяемость влечет некоторые следствия. Чтобы новый метод доступа можно было легко встроить в систему, в PostgreSQL выделен общий механизм индексирования. Его основной задачей является получение TID от метода доступа и работа с ними:  

-   чтение данных из соответствующих версий строк таблицы;
-   выборка по отдельному TID, либо сразу по набору TID (с построением битовой карты);
-   проверка видимости версий строк для текущей транзакции с учетом уровня изоляции.
  
Механизм индексирования участвует в выполнении запросов; он вызывается в соответствии с планом, построенным на этапе оптимизации. Оптимизатор, перебирая и оценивая различные пути выполнения запроса, должен понимать возможности всех методов доступа, которые потенциально можно применить. Сможет ли метод доступа отдавать данные сразу в нужном порядке, или надо отдельно предусмотреть сортировку? можно ли применить метод доступа для поиска null? — такие вопросы постоянно решает оптимизатор.  
  
Информация о методе доступа нужна не только оптимизатору. При создании индекса системе надо решить: можно ли построить индекс над несколькими столбцами? может ли данный индекс обеспечить уникальность?  
  
Итак, каждый метод доступа должен предоставить о себе всю необходимую информацию. До версии 9.6 для этого использовалась таблица pg_am, а начиная с 9.6 данные перекочевали глубже, внутрь специальных функций. С этим интерфейсом мы познакомимся чуть позже.  
  
В задачи же самого метода доступа входит все остальное:  

-   реализация алгоритма построения индекса и разбиение данных по страницам (чтобы любой индекс однотипно обрабатывался менеджером буферного кэша);
-   поиск информации в индексе по выражению «_индексированное-поле оператор выражение_»;
-   оценка стоимости использования индекса;
-   работа с блокировками, необходимая для корректного параллельного выполнения процессов;
-   формирование журнала упреждающей записи (WAL).
  
Сначала мы посмотрим возможности общего механизма индексирования, а затем перейдем к рассмотрению различных методов доступа.

## [[Механизмы сканирования]]
## [[Типы]]

## Сортировка

Если метод доступа возвращает идентификаторы строк в порядке сортировки, это дает оптимизатору дополнительные варианты выполнения запроса.  
  
Можно просканировать таблицу и затем отсортировать данные:  

```sql
set enable_indexscan=off;
explain (costs off) select * from t order by a;
```
```
QUERY PLAN
---------------------
Sort
Sort Key: a
	Seq Scan on t
(3 rows)
```

А можно прочитать данные с помощью индекса сразу в порядке сортировки:  

```sql
set enable_indexscan=on;
explain (costs off) select * from t order by a;
```
```
QUERY PLAN
-------------------------------
Index Scan using t_a_idx on t
(1 row)
```

Из всех методов доступа только btree умеет возвращать данные в отсортированном виде, так что отложим более подробный разговор до рассмотрения этого типа индекса.  

## Параллельное построение
  
Обычно построение индекса требует установки блокировки типа SHARE на таблицу. Такая блокировка позволяет читать данные из таблицы, но запрещает любые изменения, пока строится индекс.  

В этом можно убедиться, если в момент создания индекса, скажем, на таблице t, в другом сеансе выполнить запрос:  

```sql
select mode, granted from pg_locks where relation = 't'::regclass;
```
```
mode    | granted
-----------+---------
ShareLock | t
(1 row)
```

Если таблица достаточно большая и активно используется в режиме вставки, обновления или удаления, это может оказаться недопустимым — изменяющие сеансы будут ожидать освобождения блокировки длительное время.  
  
В этом случае можно воспользоваться параллельным созданием индекса:  
  
```sql
create index concurrently on t(a);
```  
Такая команда устанавливает блокировку типа SHARE UPDATE EXCLUSIVE, которая разрешает и чтение, и изменение данных (запрещается только изменение структуры таблицы, а также одновременное выполнение очистки, анализа, или построения другого индекса на той же таблице).  
  
Однако есть и обратная сторона. Во-первых, индекс будет строиться медленнее, чем обычно, поскольку вместо одного прохода по таблице выполняется два, а еще необходимо дожидаться завершения параллельных транзакций, изменяющих данные.  
  
Во-вторых, при параллельном построении индекса может возникнуть взаимоблокировка или нарушение ограничения уникальности. Индекс тем не менее создается, но в «нерабочем» состоянии; в таком случае его надо удалить и пересоздать еще раз. Нерабочие индексы отмечены словом INVALID в выводе команды psql  `\d`, а полный список можно получить запросом:  

```sql
select indexrelid::regclass index_name, indrelid::regclass table_name from pg_index where not indisvalid;
```
```
index_name | table_name
------------+------------
t_a_idx    | t
(1 row)
```

## [[Интерфейс]] методов доступа