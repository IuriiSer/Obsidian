Можно по-разному работать с TID, поставляемыми индексом. Рассмотрим пример:  
  
```sql
postgres=# create table t(a integer, b text, c boolean);
postgres=# 
	insert into t(a,b,c)
	select s.id, chr((32+random()*94)::integer), random() < 0.01
	from generate_series(1,100000) as s(id)
	order by random();
	INSERT 0 100000
postgres=# create index on t(a);
postgres=# analyze t;
```

Мы создали таблицу с тремя полями. Первое поле содержит числа от 1 до 100000, и по нему создан индекс (пока нам не важно, какой именно). Второе поле содержит различные ASCII-символы, кроме непечатных. Наконец, третье поле содержит логическое значение, истинное примерно для 1% строк, и ложное для остальных. Строки вставлены в таблицу в случайном порядке.  
  
Попробуем выбрать значение по условию «a = 1». Заметим, что условие имеет вид «_индексированное-поле оператор выражение_», где в качестве _оператора_ используется «равно», а _выражением_ (ключом поиска) является «1». В большинстве случаев условие должно иметь именно такой вид, чтобы индекс мог использоваться.  

```sql
postgres=# explain (costs off) select * from t where a = 1;
```
```
QUERY PLAN
-------------------------------
Index Scan using t_a_idx on t
Index Cond: (a = 1)
(2 rows)   
```  

В данном случае оптимизатор принял решение использовать _индексное сканирование_ (Index Scan). При индексном просмотре метод доступа возвращает значения TID по одному, до тех пор, пока подходящие строки не закончатся. Механизм индексирования по очереди обращается к тем страницам таблицы, на которые указывают TID, получает версию строки, проверяет ее видимость в соответствии с правилами многоверсионности, и возвращает полученные данные.