Для полноты картины следует сказать, что при неселективном условии оптимизатор предпочтет использованию индекса _последовательное сканирование_ таблицы целиком: 

```sql
postgres=# explain (costs off) select * from t where a <= 40000;
```
```
QUERY PLAN
------------------------
Seq Scan on t
Filter: (a <= 40000)
(2 rows)
```

И будет прав. Дело в том, что индексы работают тем лучше, чем выше селективность условия, то есть чем меньше строк ему удовлетворяет. При увеличении выборки возрастают и накладные расходы на чтение страниц индекса.  
  
Ситуация усугубляется тем, что последовательное чтение выполняется быстрее, чем чтение страниц «вразнобой». Это особенно верно для жестких дисков, где механическая операция подведения головки к дорожке занимает существенно больше времени, чем само чтение данных; в случае дисков SSD этот эффект менее выражен. Для учета разницы стоимости доступа существуют два параметра seq_page_cost и random_page_cost, которые можно устанавливать не только глобально, но и на уровне табличных пространств, учитывая таким образом характеристики разных дисковых подсистем.