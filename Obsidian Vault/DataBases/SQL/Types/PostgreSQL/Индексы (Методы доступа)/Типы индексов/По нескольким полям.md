Условия на несколько полей могут быть поддержаны с помощью _многоколоночных индексов_. Например, мы могли бы создать индекс по двум полям нашей таблицы:  

```sql
create index on t(a,b);
analyze t;
```

Оптимизатор скорее всего предпочтет такой индекс объединению битовых карт, поскольку здесь мы сразу получаем нужные TID без каких-либо вспомогательных действий:  

```sql
explain (costs off) select * from t where a <= 100 and b = 'a';
```
```
QUERY PLAN
------------------------------------------------
Index Scan using t_a_b_idx on t
Index Cond: ((a <= 100) AND (b = 'a'::text))
(2 rows)
```

Многоколоночный индекс может использоваться и для ускорения выборки по условию на часть полей — начиная с первого:  

```sql
explain (costs off) select * from t where a <= 100;
```
```
QUERY PLAN
--------------------------------------
Bitmap Heap Scan on t
Recheck Cond: (a <= 100)
	Bitmap Index Scan on t_a_b_idx
	Index Cond: (a <= 100)
(4 rows)
```

Как правило, если на первое поле не наложено условие, индекс использоваться не будет. Но в некоторых случаях оптимизатор может счесть, что это все-таки выгоднее последовательного сканирования. Подробнее мы затронем эту тему, когда будет рассматривать индексы btree.  
  
Не все методы доступа поддерживают создание индексов по нескольким столбцам.